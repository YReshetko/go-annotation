// Code generated by Constructor annotation processor. DO NOT EDIT.
// versions:
//		go-annotation: 0.0.3-alpha
//		Constructor: 0.0.3

package internal

import (
	bytes "bytes"
	common "github.com/YReshetko/go-annotation/examples/constructor/internal/common"
	constraints "golang.org/x/exp/constraints"
	http "net/http"
)

func NewAnotherStructOverride(a SomeStructure, b *SomeStructure, fn func(**SomeStructure) AnotherStruct, buff bytes.Buffer) *AnotherStruct {
	returnValue := &AnotherStruct{
		a:    a,
		b:    b,
		fn:   fn,
		buff: buff,
	}

	return returnValue
}

type AnotherStructOption func(*AnotherStruct)

func NewAnotherStructOptional(opts ...AnotherStructOption) AnotherStruct {
	rt := &AnotherStruct{}
	for _, o := range opts {
		o(rt)
	}

	return *rt
}

func WithA(v SomeStructure) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.a = v
	}
}

func WithB(v *SomeStructure) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.b = v
	}
}

func WithFn(v func(**SomeStructure) AnotherStruct) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.fn = v
	}
}

func WithBuff(v bytes.Buffer) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.buff = v
	}
}

func NewTheThirdStruct(d int, fn func(**SomeStructure) AnotherStruct, a SomeStructure, b *SomeStructure, c int) TheThirdStruct {
	returnValue := TheThirdStruct{
		d:  d,
		fn: fn,
		a:  a,
		b:  b,
		c:  c,
	}

	return returnValue
}

func NewStackStruct[T stack[T]](a stack[T], q queue[stack[T]], fn func(**SomeStructure) AnotherStruct) StackStruct[T] {
	returnValue := StackStruct[T]{
		a:  a,
		q:  q,
		fn: fn,
	}

	return returnValue
}

func NewStackQueueStruct[T comparable, V constraints.Integer](a stack[T], q queue[V], simp T, vimp V, fn func(**SomeStructure) AnotherStruct, buff bytes.Buffer) *StackQueueStruct[T, V] {
	returnValue := &StackQueueStruct[T, V]{
		a:    a,
		q:    q,
		simp: simp,
		vimp: vimp,
		fn:   fn,
		buff: buff,
		str:  make(chan map[T][]V),
	}
	returnValue.postConstruct1()
	returnValue.postConstruct2()
	returnValue.postConstruct3()

	return returnValue
}

type StackQueueStructOption[T comparable, V constraints.Integer] func(*StackQueueStruct[T, V])

func NewStackQueueStructOptional[T comparable, V constraints.Integer](opts ...StackQueueStructOption[T, V]) *StackQueueStruct[T, V] {
	rt := &StackQueueStruct[T, V]{
		str: make(chan map[T][]V),
	}
	for _, o := range opts {
		o(rt)
	}
	rt.postConstruct1()
	rt.postConstruct2()
	rt.postConstruct3()

	return rt
}

func WithSQSQ[T comparable, V constraints.Integer](v queue[V]) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.q = v
	}
}

func WithSQSSimp[T comparable, V constraints.Integer](v T) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.simp = v
	}
}

func WithSQSVimp[T comparable, V constraints.Integer](v V) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.vimp = v
	}
}

func WithSQSFn[T comparable, V constraints.Integer](v func(**SomeStructure) AnotherStruct) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.fn = v
	}
}

func WithSQSBuff[T comparable, V constraints.Integer](v bytes.Buffer) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.buff = v
	}
}

func WithSQSStr[T comparable, V constraints.Integer](v chan map[T][]V) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.str = v
	}
}

func WithSQSA[T comparable, V constraints.Integer](v stack[T]) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.a = v
	}
}

type MyStackQueueStructBuilder[T comparable, V constraints.Integer] struct {
	value StackQueueStruct[T, V]
}

func NewStackQueueStructBuilder[T comparable, V constraints.Integer]() *MyStackQueueStructBuilder[T, V] {
	return &MyStackQueueStructBuilder[T, V]{}
}

func (b *MyStackQueueStructBuilder[T, V]) BuildQField(v queue[V]) *MyStackQueueStructBuilder[T, V] {
	b.value.q = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildSimpField(v T) *MyStackQueueStructBuilder[T, V] {
	b.value.simp = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildVimpField(v V) *MyStackQueueStructBuilder[T, V] {
	b.value.vimp = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildFnField(v func(**SomeStructure) AnotherStruct) *MyStackQueueStructBuilder[T, V] {
	b.value.fn = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildBuffField(v bytes.Buffer) *MyStackQueueStructBuilder[T, V] {
	b.value.buff = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildStrField(v chan map[T][]V) *MyStackQueueStructBuilder[T, V] {
	b.value.str = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) BuildAField(v stack[T]) *MyStackQueueStructBuilder[T, V] {
	b.value.a = v
	return b
}

func (b *MyStackQueueStructBuilder[T, V]) Build() *StackQueueStruct[T, V] {
	if b.value.str == nil {
		b.value.str = make(chan map[T][]V)
	}
	b.value.postConstruct1()
	b.value.postConstruct2()
	b.value.postConstruct3()

	return &b.value
}

func NewEmbeddingConstructorExample[T comparable, V constraints.Integer](embeddedPrivateInterface embeddedPrivateInterface, ExternalEmbeddedInterface common.ExternalEmbeddedInterface, SomeStructure SomeStructure, SomeStruct *common.SomeStruct, privateEmbedded privateEmbedded) StructEmbedding[T, V] {
	returnValue := StructEmbedding[T, V]{
		embeddedPrivateInterface:  embeddedPrivateInterface,
		ExternalEmbeddedInterface: ExternalEmbeddedInterface,
		SomeStructure:             SomeStructure,
		SomeStruct:                SomeStruct,
		privateEmbedded:           privateEmbedded,
	}

	return returnValue
}

type StructEmbeddingOption[T comparable, V constraints.Integer] func(*StructEmbedding[T, V])

func NewStructEmbedding[T comparable, V constraints.Integer](opts ...StructEmbeddingOption[T, V]) StructEmbedding[T, V] {
	rt := &StructEmbedding[T, V]{}
	for _, o := range opts {
		o(rt)
	}

	return *rt
}

func WithSomeStructure[T comparable, V constraints.Integer](v SomeStructure) StructEmbeddingOption[T, V] {
	return func(rt *StructEmbedding[T, V]) {
		rt.SomeStructure = v
	}
}

func WithSomeStruct[T comparable, V constraints.Integer](v *common.SomeStruct) StructEmbeddingOption[T, V] {
	return func(rt *StructEmbedding[T, V]) {
		rt.SomeStruct = v
	}
}

func WithPrivateEmbedded[T comparable, V constraints.Integer](v privateEmbedded) StructEmbeddingOption[T, V] {
	return func(rt *StructEmbedding[T, V]) {
		rt.privateEmbedded = v
	}
}

func WithEmbeddedPrivateInterface[T comparable, V constraints.Integer](v embeddedPrivateInterface) StructEmbeddingOption[T, V] {
	return func(rt *StructEmbedding[T, V]) {
		rt.embeddedPrivateInterface = v
	}
}

func WithExternalEmbeddedInterface[T comparable, V constraints.Integer](v common.ExternalEmbeddedInterface) StructEmbeddingOption[T, V] {
	return func(rt *StructEmbedding[T, V]) {
		rt.ExternalEmbeddedInterface = v
	}
}

type StructEmbeddingBuilder[T comparable, V constraints.Integer] struct {
	value StructEmbedding[T, V]
}

func NewStructEmbeddingBuilder[T comparable, V constraints.Integer]() *StructEmbeddingBuilder[T, V] {
	return &StructEmbeddingBuilder[T, V]{}
}

func (b *StructEmbeddingBuilder[T, V]) PrivateEmbedded(v privateEmbedded) *StructEmbeddingBuilder[T, V] {
	b.value.privateEmbedded = v
	return b
}

func (b *StructEmbeddingBuilder[T, V]) EmbeddedPrivateInterface(v embeddedPrivateInterface) *StructEmbeddingBuilder[T, V] {
	b.value.embeddedPrivateInterface = v
	return b
}

func (b *StructEmbeddingBuilder[T, V]) ExternalEmbeddedInterface(v common.ExternalEmbeddedInterface) *StructEmbeddingBuilder[T, V] {
	b.value.ExternalEmbeddedInterface = v
	return b
}

func (b *StructEmbeddingBuilder[T, V]) SomeStructure(v SomeStructure) *StructEmbeddingBuilder[T, V] {
	b.value.SomeStructure = v
	return b
}

func (b *StructEmbeddingBuilder[T, V]) SomeStruct(v *common.SomeStruct) *StructEmbeddingBuilder[T, V] {
	b.value.SomeStruct = v
	return b
}

func (b *StructEmbeddingBuilder[T, V]) Build() StructEmbedding[T, V] {

	return b.value
}

func NewSomeSomeStructureThisIsMyTemplate(c *bool, d **complex128) SomeStructure {
	returnValue := SomeStructure{
		c:          c,
		d:          d,
		slice:      make([]map[chan int]string, 5, 15),
		slice2:     []map[chan int]string{},
		maps:       make(map[chan []int]struct{ A http.Request }, 5),
		chanals:    make(chan []struct{ A http.Request }),
		chanalsCap: make(chan []struct{ A http.Request }, 5),
	}

	return returnValue
}

type SomeStructureOption func(*SomeStructure)

func NewSomeSomeStructureThisIsMyTemplateOptional(opts ...SomeStructureOption) SomeStructure {
	rt := &SomeStructure{
		chanalsCap: make(chan []struct{ A http.Request }, 5),
		slice:      make([]map[chan int]string, 5, 15),
		slice2:     []map[chan int]string{},
		maps:       make(map[chan []int]struct{ A http.Request }, 5),
		chanals:    make(chan []struct{ A http.Request }),
	}
	for _, o := range opts {
		o(rt)
	}

	return *rt
}

func WithC(v *bool) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.c = v
	}
}

func WithD(v **complex128) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.d = v
	}
}

func WithSlice(v []map[chan int]string) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.slice = v
	}
}

func WithSlice2(v []map[chan int]string) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.slice2 = v
	}
}

func WithMaps(v map[chan []int]struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.maps = v
	}
}

func WithChanals(v chan []struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.chanals = v
	}
}

func WithChanalsCap(v chan []struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.chanalsCap = v
	}
}

type MySomeStructureBuilder struct {
	value SomeStructure
}

func NewSomeStructureBuilder() *MySomeStructureBuilder {
	return &MySomeStructureBuilder{}
}

func (b *MySomeStructureBuilder) BuildChanalsCapField(v chan []struct{ A http.Request }) *MySomeStructureBuilder {
	b.value.chanalsCap = v
	return b
}

func (b *MySomeStructureBuilder) BuildCField(v *bool) *MySomeStructureBuilder {
	b.value.c = v
	return b
}

func (b *MySomeStructureBuilder) BuildDField(v **complex128) *MySomeStructureBuilder {
	b.value.d = v
	return b
}

func (b *MySomeStructureBuilder) BuildSliceField(v []map[chan int]string) *MySomeStructureBuilder {
	b.value.slice = v
	return b
}

func (b *MySomeStructureBuilder) BuildSlice2Field(v []map[chan int]string) *MySomeStructureBuilder {
	b.value.slice2 = v
	return b
}

func (b *MySomeStructureBuilder) BuildMapsField(v map[chan []int]struct{ A http.Request }) *MySomeStructureBuilder {
	b.value.maps = v
	return b
}

func (b *MySomeStructureBuilder) BuildChanalsField(v chan []struct{ A http.Request }) *MySomeStructureBuilder {
	b.value.chanals = v
	return b
}

func (b *MySomeStructureBuilder) Build() *SomeStructure {
	if b.value.maps == nil {
		b.value.maps = make(map[chan []int]struct{ A http.Request }, 5)
	}
	if b.value.chanals == nil {
		b.value.chanals = make(chan []struct{ A http.Request })
	}
	if b.value.chanalsCap == nil {
		b.value.chanalsCap = make(chan []struct{ A http.Request }, 5)
	}
	if b.value.slice == nil {
		b.value.slice = make([]map[chan int]string, 5, 15)
	}
	if b.value.slice2 == nil {
		b.value.slice2 = []map[chan int]string{}
	}

	return &b.value
}
