// Code generated by Constructor annotation processor. DO NOT EDIT.
// versions:
//		go-annotation: 0.0.2-alpha
//		Constructor: 0.0.2

package internal

import (
	bytes "bytes"
	constraints "golang.org/x/exp/constraints"
	http "net/http"
)

func NewSomeSomeStructureThisIsMyTemplate(c *bool, d **complex128) SomeStructure {
	return SomeStructure{
		c:          c,
		d:          d,
		slice:      make([]map[chan int]string, 5, 15),
		slice2:     []map[chan int]string{},
		maps:       make(map[chan []int]struct{ A http.Request }, 5),
		chanals:    make(chan []struct{ A http.Request }),
		chanalsCap: make(chan []struct{ A http.Request }, 5),
	}
}

type SomeStructureOption func(*SomeStructure)

func NewSomeSomeStructureThisIsMyTemplateOptional(opts ...SomeStructureOption) SomeStructure {
	rt := &SomeStructure{
		maps:       make(map[chan []int]struct{ A http.Request }, 5),
		chanals:    make(chan []struct{ A http.Request }),
		chanalsCap: make(chan []struct{ A http.Request }, 5),
		slice:      make([]map[chan int]string, 5, 15),
		slice2:     []map[chan int]string{},
	}
	for _, o := range opts {
		o(rt)
	}
	return *rt
}

func WithSlice(v []map[chan int]string) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.slice = v
	}
}

func WithSlice2(v []map[chan int]string) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.slice2 = v
	}
}

func WithMaps(v map[chan []int]struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.maps = v
	}
}

func WithChanals(v chan []struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.chanals = v
	}
}

func WithChanalsCap(v chan []struct{ A http.Request }) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.chanalsCap = v
	}
}

func WithC(v *bool) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.c = v
	}
}

func WithD(v **complex128) SomeStructureOption {
	return func(rt *SomeStructure) {
		rt.d = v
	}
}

func NewAnotherStructOverride(a SomeStructure, b *SomeStructure, fn func(**SomeStructure) AnotherStruct, buff bytes.Buffer) *AnotherStruct {
	return &AnotherStruct{
		a:    a,
		b:    b,
		fn:   fn,
		buff: buff,
	}
}

type AnotherStructOption func(*AnotherStruct)

func NewAnotherStructOptional(opts ...AnotherStructOption) AnotherStruct {
	rt := &AnotherStruct{}
	for _, o := range opts {
		o(rt)
	}
	return *rt
}

func WithA(v SomeStructure) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.a = v
	}
}

func WithB(v *SomeStructure) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.b = v
	}
}

func WithFn(v func(**SomeStructure) AnotherStruct) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.fn = v
	}
}

func WithBuff(v bytes.Buffer) AnotherStructOption {
	return func(rt *AnotherStruct) {
		rt.buff = v
	}
}

func NewTheThirdStruct(fn func(**SomeStructure) AnotherStruct, a SomeStructure, b *SomeStructure, c int, d int) TheThirdStruct {
	return TheThirdStruct{
		fn: fn,
		a:  a,
		b:  b,
		c:  c,
		d:  d,
	}
}

func NewStackStruct[T stack[T]](a stack[T], q queue[stack[T]], fn func(**SomeStructure) AnotherStruct) StackStruct[T] {
	return StackStruct[T]{
		a:  a,
		q:  q,
		fn: fn,
	}
}

func NewStackQueueStruct[T comparable, V constraints.Integer](a stack[T], q queue[V], fn func(**SomeStructure) AnotherStruct, buff bytes.Buffer) StackQueueStruct[T, V] {
	return StackQueueStruct[T, V]{
		a:    a,
		q:    q,
		fn:   fn,
		buff: buff,
		str:  make(chan map[T][]V),
	}
}

type StackQueueStructOption[T comparable, V constraints.Integer] func(*StackQueueStruct[T, V])

func NewStackQueueStructOptional[T comparable, V constraints.Integer](opts ...StackQueueStructOption[T, V]) *StackQueueStruct[T, V] {
	rt := &StackQueueStruct[T, V]{
		str: make(chan map[T][]V),
	}
	for _, o := range opts {
		o(rt)
	}
	return rt
}

func WithSQSA[T comparable, V constraints.Integer](v stack[T]) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.a = v
	}
}

func WithSQSQ[T comparable, V constraints.Integer](v queue[V]) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.q = v
	}
}

func WithSQSFn[T comparable, V constraints.Integer](v func(**SomeStructure) AnotherStruct) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.fn = v
	}
}

func WithSQSBuff[T comparable, V constraints.Integer](v bytes.Buffer) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.buff = v
	}
}

func WithSQSStr[T comparable, V constraints.Integer](v chan map[T][]V) StackQueueStructOption[T, V] {
	return func(rt *StackQueueStruct[T, V]) {
		rt.str = v
	}
}
